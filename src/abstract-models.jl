export AbstractSpectralModel,
    allocate_model_output,
    AbstractSpectralModelKind,
    Multiplicative,
    Additive,
    Convolutional,
    modelkind,
    AbstractSpectralModelImplementation,
    XSPECImplementation,
    JuliaImplementation,
    implementation,
    invokemodel,
    invokemodel!,
    objective_cache_count

"""
    abstract type AbstractSpectralModelKind

Abstract type of all model kinds. The algebra of models is as follows
```julia
A + A = A
M * M = M
M * A = A
C(A)  = A
```
where `A` is [`Additive`](@ref), `M` is [`Multiplicative`](@ref), and `C` is [`Convolutional`](@ref).
All other operations are prohibited, e.g. `C(M)` or `M * C`. To obtain `M * C` there must be an
additive component, e.g. `M * C(A)`.
"""
abstract type AbstractSpectralModelKind end
"""
    Additive <: AbstractSpectralModelKind
    Additive()

Additive models are effectively the sources of photons, and are the principle building blocks
of composite models. Every additive model has a normalisation parameter which re-scales the
output by a constant factor `K`.

!!! note
    Defining custom additive models requires special care. See [Defining new models](@ref).
"""
struct Additive <: AbstractSpectralModelKind end
"""
    Multiplicative <: AbstractSpectralModelKind
    Multiplicative()

Multiplicative models act on [`Additive`](@ref) models, by element-wise
multiplying the output in each domain bin of the additive model by a different factor.
"""
struct Multiplicative <: AbstractSpectralModelKind end
"""
    Convolutional <: AbstractSpectralModelKind
    Convolutional()

Convolutional models act on the output generated by [`Additive`](@ref) models, similar to
[`Multiplicative`](@ref) models, however may convolve kernels through the output also.
"""
struct Convolutional <: AbstractSpectralModelKind end

"""
    abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end

Supertype of all spectral models, tracking the number type `T` and
[`AbstractSpectralModelKind`](@def) denoted `K`.

## Implementation

Sub-types must implement the following interface (see the function's
documentation for examples):
- [`SpectralFitting.invoke!`](@ref)

The parameters of the model must be of types `FitParam` when default
initialised, as this is used to perform introspection. The boiler plate for a
new model is as follows:

```julia
struct MyNewModel{T} <: AbstractSpectralModel{T,Additive}
    "Normalisation (required by Additive kinds)
    K::T
    "First parameter"
    p1::T
    "Second parameter"
    p2::T
end

# add a default keyword constructor
function MyNewModel(;K = FitParam(1.0), p1 = FitParam(2.0), p2 = FitParam(0.1))
    MyNewModel(K, p1, p2)
end

function SpectralFitting.invoke!(output, domain, model::MyNewModel)
    # implementation must overwrite `output`
    output .= 0
end
```

## Usage

The available API for a spectral model is detailed below:

- [`invokemodel`](@ref) / [`invokemodel!`](@ref): the primary way to invoke a model.
- [`allocate_model_output`](@ref): allocate the output matrix for the model.

The following query functions exist:

- [`modelkind`](@ref) for obtaining `K`
- [`implementation`](@ref) used to ascertain whether we can do things like
  automatic differentiation through this model.
- [`parameter_count`](@ref) to return a compile-time integer representing the
  total number of parameters in the model.
- [`parameter_vector`](@ref) to obtain a vector where every element is a
  [`FitParam`](@ref) in the same order as the struct fields.
- [`objective_cache_count`](@ref) how many output arrays this model needs to be
  invoked (only used for [`CompositeModel`](@ref)).
- [`supports`](@ref) what [`AbstractLayout`](@ref) are supported by this model.

Model introspection exists via the following functions::

- [`unpack_as_named_tuple`](@ref) return the model fields as a named tuple.
- [`unpack_parameters_as_named_tuple`](@ref) similar, but ignores any closure fields.

Conversion functions include:
- [`remake_with_number_type`](@ref) for converting a model with
  [`FitParam`](@ref) type parameters to a primitive type (e.g. `Float64`).
- [`remake_with_parameters`](@ref) for rebuilding a model with all parameters
  replaced with the passed new values.

The parametric type parameter `T` is the number type of the model and `K`
defines the [`AbstractSpectralModelKind`](@ref).
"""
abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end
supports(::Type{<:AbstractSpectralModel}) = (ContiguouslyBinned(),)

"""
    modelkind(M::Type{<:AbstractSpectralModel})
    modelkind(::AbstractSpectralModel)

Return the kind of model given by `M`: either `Additive`, `Multiplicative`, or `Convolutional`.
"""
modelkind(::Type{<:AbstractSpectralModel{T,K}}) where {T,K} = K()
modelkind(::M) where {M<:AbstractSpectralModel} = modelkind(M)

"""
    abstract type AbstractSpectralModelImplementation end

Details about the implementation are represented by this abstract type, used in
the trait pattern. Concrete types are

- `JuliaImplementation()`: means the model is implemented in the Julia
  programming language.
- `XSPECImplementation()`: means the model is vendored from the XSPEC model
  library.
"""
abstract type AbstractSpectralModelImplementation end
struct XSPECImplementation <: AbstractSpectralModelImplementation end
struct JuliaImplementation <: AbstractSpectralModelImplementation end

"""
    implementation(model::AbstractSpectralModel)
    implementation(::Type{<:AbstractSpectralModel})

Get the [`AbstractSpectralModelImplementation`](@ref) for a given
[`AbstractSpectralModel`](@ref) or model type.

This is used primarily to learn what optimizations we can do with a model, for
example propagating auto-diff gradients through a model or arbitrary precision
numbers.
"""
implementation(::Type{<:AbstractSpectralModel}) = JuliaImplementation()
implementation(model::AbstractSpectralModel) = implementation(typeof(model))

# interface for ConstructionBase.jl
function ConstructionBase.setproperties(
    model::M,
    patch::NamedTuple{names},
) where {M<:AbstractSpectralModel,names}
    symbols = keys(parameter_named_tuple(model))
    args = (s in names ? getproperty(patch, s) : getproperty(model, s) for s in symbols)
    M(args...)
end
ConstructionBase.constructorof(::Type{M}) where {M<:AbstractSpectralModel} = M

# implementation interface
# never to be called directly
# favour `invokemodel!` instead
"""
    SpectralFitting.invoke!(output, domain, M::Type{<:AbstractSpectralModel}, params...)

Used to define the behaviour of models. Should calculate the output of the model
and write in-place into `output`. The model parameters are passed in the model structure.

!!! warning
    This function should not be called directly. Use [`invokemodel`](@ref)
    instead. `invoke!` is only to define the model, not to use it. Users should
    always call models using [`invokemodel`](@ref) or [`invokemodel!`](@ref) to
    ensure normalisations and closures are accounted for.

## Example

```julia
Base.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Multiplicative}
    p1::T = FitParam(1.0)
    p2::T = FitParam(2.0)
    p3::T = FitParam(3.0)
end
```
would have the arguments passed to `invoke!` as
```julia
function SpectralFitting.invoke!(output, domain, model::MyModel)
    # ...
end
```
"""
invoke!(output, domain, M::AbstractSpectralModel) = error("Not defined for $(M).")

"""
    invokemodel(domain, model::AbstractSpectralModel)

Invoke the [`AbstractSpectralModel`](@ref) given by `model` over the domain `domain`.

This function will perform any normalisation or post-processing tasks that a
specific model kind may require, e.g. multiplying by a normalisation constant for [`Additive`](@ref) models.

!!! note

`invokemodel` allocates the needed output arrays based on the element type of `free_params` to allow
automatic differentation libraries to calculate parameter gradients.

In-place non-allocating variants are the [`invokemodel!`](@ref) functions.

# Example

```julia
model = PowerLaw()
domain = collect(range(0.1, 20.0, 100))

invokemodel(domain, model)
```
"""
function invokemodel(domain, m::AbstractSpectralModel)
    output = allocate_model_output(m, domain) |> vec
    invokemodel!(output, domain, m)
    output
end

"""
    invokemodel!(output, domain, model)
    invokemodel!(output, domain, model, params::AbstractVector)
    invokemodel!(output, domain, model, params::ParameterCache)

In-place variant of [`invokemodel`](@ref), calculating the output of an
[`AbstractSpectralModel`](@ref) given by `model`, optionally overriding the
parameters using a [`ParameterCache`](@ref) or an `AbstractVector`.

The `output` may not necessarily be a single vector, and one should use
[`allocate_model_output`](@ref) to allocate the output structure.

# Example

```julia
model = PowerLaw()
domain = collect(range(0.1, 20.0, 100))
output = allocate_model_output(model, domain)
invokemodel!(output, domain, model)
```
"""
@inline function invokemodel!(f, e, m::AbstractSpectralModel{<:FitParam})
    # need to extract the parameter values
    model = remake_with_number_type(m)
    invokemodel!(view(f, :, 1), e, model)
end
@inline function invokemodel!(f, e, m::AbstractSpectralModel, cache::ParameterCache)
    invokemodel!(f, e, m, cache.parameters)
end
@inline function invokemodel!(f, e, m::AbstractSpectralModel, parameters::AbstractArray)
    invokemodel!(f, e, remake_with_parameters(m, parameters))
end
@inline function invokemodel!(
    output,
    domain,
    m::AbstractSpectralModel{<:Number,K},
) where {K}
    invokemodel!(output, domain, K(), m)
end
@inline function invokemodel!(output, domain, ::Additive, model::AbstractSpectralModel)
    invoke!(vec(output), domain, model)
    # perform additive normalisation
    K = normalisation(model)
    @. output *= K
    output
end
@inline function invokemodel!(
    output,
    domain,
    ::AbstractSpectralModelKind,
    model::AbstractSpectralModel,
)
    invoke!(vec(output), domain, model)
    output
end

normalisation(model::AbstractSpectralModel{T,Additive}) where {T} = model.K

"""
    allocate_model_output(model::AbstractSpectralModel, domain::AbstractVector)

Allocate the output space for the [`AbstractSpectralModel`](@ref) for a given
domain. The output type will be the promoted element type of the model and
domain.

Uses [`construct_objective_cache`](@ref) to construct the appropriate layout.
"""
function allocate_model_output(
    model::AbstractSpectralModel{T1},
    domain::AbstractVector{T2},
) where {T1,T2}
    T = promote_type(T1 <: FitParam ? T1.parameters[1] : T1, T2)
    construct_objective_cache(T, model, domain)
end

function Base.copy(m::AbstractSpectralModel)
    typeof(m)((copy(getproperty(m, f)) for f in fieldnames(typeof(m)))...)
end

# printing
_model_name(model::AbstractSpectralModel) = Base.typename(typeof(model)).name

function _printinfo(io::IO, m::AbstractSpectralModel{T}; bindings = nothing) where {T}
    println(io, _model_name(m))
    println(io, "T = $T")
end

function _printinfo(
    io::IO,
    m::M;
    bindings = nothing,
) where {M<:AbstractSpectralModel{<:FitParam}}
    param_tuple = unpack_parameters_as_named_tuple(m)
    params = [s => p for (s, p) in zip(keys(param_tuple), param_tuple)]
    basename = _model_name(m)
    print(io, "$(basename)\n")

    info_tuples = [get_info_tuple(val) for (_, val) in params]
    q1, q2, q3, q4 = map(1:4) do i
        maximum(j -> length("$(j[i])"), info_tuples) + 1
    end

    param_offset = 5 + maximum(params) do (s, _)
        length("$s")
    end

    for (i, (s, param)) in enumerate(params)
        free = param isa FitParam ? !isfrozen(param) : true
        if !isnothing(bindings) && !isnothing(get(bindings, s, nothing))
            print(io, lpad(s, param_offset), " -> ")
            printstyled(io, bindings[s], color = :magenta)
            println(io)
        else
            param, nothing
            _print_param(io, free, String(s), param, param_offset, q1, q2, q3, q4)
        end
    end
end

function Base.show(io::IO, ::MIME"text/plain", @nospecialize(model::AbstractSpectralModel))
    buff = IOBuffer()
    _printinfo(IOContext(buff, io), model)
    s = String(take!(buff))
    print(io, encapsulate(s))
end

# TODO: all of the below need unit tests that make sure they are type-stable

function closure_and_parameter_types(
    M::Type{<:AbstractSpectralModel{T}},
) where {T<:FitParam}
    FTypes = fieldtypes(M)
    P = count(T -> T<:FitParam, FTypes)
    C = length(FTypes) - P
    FTypes[1:C], FTypes[(C+1):(P+C)]
end

function closure_and_parameter(
    model::M,
) where {M<:AbstractSpectralModel{T}} where {T<:FitParam}
    C, P = closure_and_parameter_types(M)
    tuple = _unpack_as_tuple(model)
    closures = tuple[1:length(C)]
    parameters = tuple[(length(C)+1):(length(C)+length(P))]
    @assert all(i -> i isa FitParam, parameters) "All non-fit parameters must be the first fields in a model structure."
    closures, parameters
end

"""
    parameter_count(m::AbstractSpectralModel)

Return the total number of parameters of the model (i.e. how many fields are
[`FitParam`](@ref).
"""
function parameter_count(model::M) where {M<:AbstractSpectralModel{<:FitParam}}
    _, P = closure_and_parameter_types(M)
    length(P)
end

function _unpack_as_tuple(model::M) where {M<:AbstractSpectralModel}
    ((getfield(model, f) for f in fieldnames(M))...,)
end

"""
    unpack_as_named_tuple(m::AbstractSpectralModel)

Return every field of the model (whether parameter or not) in a named tuple.
"""
function unpack_as_named_tuple(model::M) where {M<:AbstractSpectralModel}
    NamedTuple{fieldnames(M)}(_unpack_as_tuple(model))
end

"""
    unpack_parameters_as_named_tuple(m::AbstractSpectralModel)

Similar to [`unpack_as_named_tuple`](@ref) but only for the [`FitParam`](@ref) field types.
"""
function unpack_parameters_as_named_tuple(model::M) where {M<:AbstractSpectralModel}
    _, ps = closure_and_parameter(model)
    names = fieldnames(M)[(end-length(ps)+1):end]
    NamedTuple{names}(ps)
end

"""
    remake_with_number_type(model::AbstractSpectralModel{<:FitParam{T}})

Remake the model with all [`FitParam`](@ref) unpacked into their backing type
`T`.
"""
function remake_with_number_type(model::AbstractSpectralModel{<:FitParam})
    closures, parameters = closure_and_parameter(model)
    remake_with_parameters(model, ((get_value(f) for f in parameters)...,))
end

"""
    remake_with_parameters(model::AbstractSpectralModel, parameters)

Rebuild the model with all [`FitParam`](@ref) type parameters replaced with
`parameters`, in the same order as they appear in the fields of the struct.
"""
function remake_with_parameters(model::AbstractSpectralModel, parameters::AbstractVector)
    indices = (1:parameter_count(model)...,)
    remake_with_parameters(model, map(i -> parameters[i], indices))
end

function remake_with_parameters(model::AbstractSpectralModel, parameters::Tuple)
    closures, _ = closure_and_parameter(model)
    Base.typename(typeof(model)).wrapper(closures..., parameters...)
end

parameter_vector(model::AbstractSpectralModel) =
    collect(unpack_parameters_as_named_tuple(model))

make_parameter_cache(model::AbstractSpectralModel) = ParameterCache(parameter_vector(model))

function _all_parameters_with_symbols(model::AbstractSpectralModel)
    ps = unpack_parameters_as_named_tuple(model)
    [values(ps)...], [String.(keys(ps))...]
end

paramtype(::Type{<:AbstractSpectralModel{T}}) where {T} = paramtype(T)
