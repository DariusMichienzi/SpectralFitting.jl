export AbstractSpectralModel,
    allocate_model_output,
    AbstractSpectralModelKind,
    Multiplicative,
    Additive,
    numbertype,
    paramtype,
    Convolutional,
    modelkind,
    AbstractSpectralModelImplementation,
    XSPECImplementation,
    JuliaImplementation,
    implementation,
    invokemodel,
    invokemodel!,
    objective_cache_count,
    make_parameter_cache

"""
    abstract type AbstractSpectralModelKind

Abstract type of all model kinds. The algebra of models is as follows
```julia
A + A = A
M * M = M
M * A = A
C(A)  = A
```
where `A` is [`Additive`](@ref), `M` is [`Multiplicative`](@ref), and `C` is [`Convolutional`](@ref).
All other operations are prohibited, e.g. `C(M)` or `M * C`. To obtain `M * C` there must be an
additive component, e.g. `M * C(A)`.
"""
abstract type AbstractSpectralModelKind end
"""
    Additive <: AbstractSpectralModelKind
    Additive()

Additive models are effectively the sources of photons, and are the principle building blocks
of composite models. Every additive model has a normalisation parameter which re-scales the
output by a constant factor `K`.

!!! note
    Defining custom additive models requires special care. See [Defining new models](@ref).
"""
struct Additive <: AbstractSpectralModelKind end
"""
    Multiplicative <: AbstractSpectralModelKind
    Multiplicative()

Multiplicative models act on [`Additive`](@ref) models, by element-wise
multiplying the output in each domain bin of the additive model by a different factor.
"""
struct Multiplicative <: AbstractSpectralModelKind end
"""
    Convolutional <: AbstractSpectralModelKind
    Convolutional()

Convolutional models act on the output generated by [`Additive`](@ref) models, similar to
[`Multiplicative`](@ref) models, however may convolve kernels through the output also.
"""
struct Convolutional <: AbstractSpectralModelKind end

"""
    abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end

Supertype of all spectral models, tracking the number type `T` and
[`AbstractSpectralModelKind`](@def) denoted `K`.

## Implementation

Sub-types must implement the following interface (see the function's
documentation for examples):
- [`SpectralFitting.invoke!`](@ref)

## Usage

The available API for a spectral model is detailed below:

- [`invokemodel`](@ref) / [`invokemodel!`](@ref): the primary way to invoke a model.
- [`allocate_model_output`](@ref): allocate the output matrix for the model.

The following query functions exist:

- [`modelkind`](@ref) for obtaining `K`
- [`numbertype`](@ref) for obtaining `T`
- [`implementation`](@ref) used to assertain whether we can do things like
  automatic differentation through this model.

Model reflection is supported by the following functions. These are intended for internal use and are not exported.

- [`parameter_named_tuple`](@ref)
- [`parameter_tuple`](@ref)
- [`remake_model_with_parameters`](@ref)
- [`destructure_model`](@ref)

The parametric type parameter `T` is the number type of the model and `K` defines the [`AbstractSpectralModelKind`](@ref).
"""
abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end
supports(::Type{<:AbstractSpectralModel}) = (ContiguouslyBinned(),)

"""
    numbertype(::AbstractSpectralModel)

Get the numerical type of the model. This goes through [`FitParam`](@ref), so
that the number type returned is as close to a primative as possible.

See also [`paramtype`](@ref).

## Example

```julia
numbertype(PowerLaw()) == Float64
```
"""
numbertype(::AbstractSpectralModel{T}) where {T<:Number} = T
numbertype(::AbstractSpectralModel{FitParam{T}}) where {T<:Number} = T

"""
    paramtype(::AbstractSpectralModel)

Get the parameter type of the model. This, unlike [`numbertype`](@ref) does not
go through [`FitParam`](@ref).

## Example

```julia
paramtype(PowerLaw()) == FitParam{Float64}
```
"""
paramtype(::T) where {T<:AbstractSpectralModel} = paramtype(T)
paramtype(::Type{<:AbstractSpectralModel{T}}) where {T} = T

"""
    modelkind(M::Type{<:AbstractSpectralModel})
    modelkind(::AbstractSpectralModel)

Return the kind of model given by `M`: either `Additive`, `Multiplicative`, or `Convolutional`.
"""
modelkind(::Type{<:AbstractSpectralModel{T,K}}) where {T,K} = K()
modelkind(::M) where {M<:AbstractSpectralModel} = modelkind(M)

"""
    abstract type AbstractSpectralModelImplementation end

Details about the implementation are represented by this abstract type, used in
the trait pattern. Concrete types are

- `JuliaImplementation()`: means the model is implemented in the Julia
  programming language.
- `XSPECImplementation()`: means the model is vendored from the XSPEC model
  library.
"""
abstract type AbstractSpectralModelImplementation end
struct XSPECImplementation <: AbstractSpectralModelImplementation end
struct JuliaImplementation <: AbstractSpectralModelImplementation end

"""
    implementation(model::AbstractSpectralModel)
    implementation(::Type{<:AbstractSpectralModel})

Get the [`AbstractSpectralModelImplementation`](@ref) for a given
[`AbstractSpectralModel`](@ref) or model type.

This is used primarily to learn what optimizations we can do with a model, for
example propagating auto-diff gradients through a model or arbitrary precision
numbers.
"""
implementation(::Type{<:AbstractSpectralModel}) = JuliaImplementation()
implementation(model::AbstractSpectralModel) = implementation(typeof(model))

# interface for ConstructionBase.jl
function ConstructionBase.setproperties(
    model::M,
    patch::NamedTuple{names},
) where {M<:AbstractSpectralModel,names}
    symbols = keys(parameter_named_tuple(model))
    args = (s in names ? getproperty(patch, s) : getproperty(model, s) for s in symbols)
    M(args...)
end
ConstructionBase.constructorof(::Type{M}) where {M<:AbstractSpectralModel} = M

# implementation interface
# never to be called directly
# favour `invokemodel!` instead
"""
    SpectralFitting.invoke!(output, domain, M::Type{<:AbstractSpectralModel}, params...)

Used to define the behaviour of models. Should calculate the output of the model
and write in-place into `output`. The model parameters are passed in the model structure.

!!! warning
    This function should not be called directly. Use [`invokemodel`](@ref)
    instead. `invoke!` is only to define the model, not to use it. Users should
    always call models using [`invokemodel`](@ref) or [`invokemodel!`](@ref) to
    ensure normalisations and closures are accounted for.

## Example

```julia
Base.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Multiplicative}
    p1::T = FitParam(1.0)
    p2::T = FitParam(2.0)
    p3::T = FitParam(3.0)
end
```
would have the arguments passed to `invoke!` as
```julia
function SpectralFitting.invoke!(output, domain, model::MyModel)
    # ...
end
```
"""
invoke!(output, domain, M::AbstractSpectralModel) = error("Not defined for $(M).")

"""
    invokemodel(domain, model::AbstractSpectralModel)

Invoke the [`AbstractSpectralModel`](@ref) given by `model` over the domain `domain`.

This function will perform any normalisation or post-processing tasks that a
specific model kind may require, e.g. multiplying by a normalisation constant for [`Additive`](@ref) models.

!!! note

`invokemodel` allocates the needed output arrays based on the element type of `free_params` to allow
automatic differentation libraries to calculate parameter gradients.

In-place non-allocating variants are the [`invokemodel!`](@ref) functions.

# Example

```julia
model = PowerLaw()
domain = collect(range(0.1, 20.0, 100))

invokemodel(domain, model)
```
"""
function invokemodel(domain, m::AbstractSpectralModel)
    output = allocate_model_output(m, domain) |> vec
    invokemodel!(output, domain, m)
    output
end

"""
    invokemodel!(output, domain, model)
    invokemodel!(output, domain, model, params::AbstractVector)
    invokemodel!(output, domain, model, params::ParameterCache)

In-place variant of [`invokemodel`](@ref), calculating the output of an
[`AbstractSpectralModel`](@ref) given by `model`, optionally overriding the
parameters using a [`ParameterCache`](@ref) or an `AbstractVector`.

The `output` may not necessarily be a single vector, and one should use
[`allocate_model_output`](@ref) to allocate the output structure.

# Example

```julia
model = PowerLaw()
domain = collect(range(0.1, 20.0, 100))
output = allocate_model_output(model, domain)
invokemodel!(output, domain, model)
```
"""
@inline function invokemodel!(f, e, m::AbstractSpectralModel{<:FitParam})
    # need to extract the parameter values
    model = remake_with_number_type(m)
    invokemodel!(view(f, :, 1), e, model)
end
@inline function invokemodel!(f, e, m::AbstractSpectralModel, cache::ParameterCache)
    invokemodel!(f, e, m, cache.parameters)
end
@inline function invokemodel!(f, e, m::AbstractSpectralModel, parameters::AbstractArray)
    invokemodel!(view(f, :, 1), e, remake_model_with_parameters(m, parameters))
end
@inline function invokemodel!(
    f::AbstractVector,
    e::AbstractVector,
    m::AbstractSpectralModel{<:Number,K},
) where {K}
    invokemodel!(f, e, K(), m)
end
@inline function invokemodel!(
    output::AbstractVector,
    domain::AbstractVector,
    ::Additive,
    model::AbstractSpectralModel,
)
    invoke!(output, domain, model)
    # perform additive normalisation
    K = normalisation(model)
    @. output *= K
    output
end
@inline function invokemodel!(
    output::AbstractVector,
    domain::AbstractVector,
    ::AbstractSpectralModelKind,
    model::AbstractSpectralModel,
)
    invoke!(output, domain, model)
    output
end

normalisation(model::AbstractSpectralModel{T,Additive}) where {T} = model.K

"""
    allocate_model_output(model::AbstractSpectralModel, domain::AbstractVector)

Allocate the output space for the [`AbstractSpectralModel`](@ref) for a given
domain. The output type will be the promoted element type of the model and
domain.

Uses [`construct_objective_cache`](@ref) to construct the appropriate layout.
"""
function allocate_model_output(
    model::AbstractSpectralModel{T1},
    domain::AbstractVector{T2},
) where {T1,T2}
    T = promote_type(T1 <: FitParam ? T1.parameters[1] : T1, T2)
    construct_objective_cache(T, model, domain)
end

function Base.copy(m::AbstractSpectralModel)
    typeof(m)((copy(getproperty(m, f)) for f in fieldnames(typeof(m)))...)
end

# printing

function _printinfo(io::IO, m::M; bindings = nothing) where {M<:AbstractSpectralModel}
    param_tuple = parameter_named_tuple(m)
    params = [String(s) => p for (s, p) in zip(keys(param_tuple), param_tuple)]
    basename = Base.typename(M).name
    print(io, "$(basename)\n")

    info_tuples = [get_info_tuple(val) for (_, val) in params]
    q1, q2, q3, q4 = map(1:4) do i
        maximum(j -> length("$(j[i])"), info_tuples) + 1
    end

    param_offset = 5 + maximum(params) do (s, _)
        length("$s")
    end

    for (i, (s, param)) in enumerate(params)
        free = param isa FitParam ? !isfrozen(param) : true
        val, binding = if !isnothing(bindings) && !isempty(bindings)
            get(bindings, i, param => nothing)
        else
            param, nothing
        end
        _print_param(io, free, s, val, param_offset, q1, q2, q3, q4; binding)
    end
end

function Base.show(io::IO, ::MIME"text/plain", @nospecialize(model::AbstractSpectralModel))
    buff = IOBuffer()
    _printinfo(buff, model)
    s = String(take!(buff))
    print(io, encapsulate(s))
end

# todo: this function could be cleaned up with some generated hackery 
function remake_with_number_type(model::AbstractSpectralModel{P}, T::Type) where {P}
    params = parameter_tuple(model)
    new_params = if P <: FitParam
        convert.(T, get_value.(params))
    else
        convert.(T, param)
    end
    remake_model_with_parameters(model, new_params)
end
remake_with_number_type(model::AbstractSpectralModel{FitParam{T}}) where {T} =
    remake_with_number_type(model, T)

function make_parameter_cache(model::AbstractSpectralModel)
    parameters = collect(parameter_tuple(model))
    ParameterCache(parameters)
end

function make_diff_parameter_cache(
    model::AbstractSpectralModel;
    param_diff_cache_size = nothing,
)
    parameters = collect(parameter_tuple(model))
    free_mask = _make_free_mask(parameters)

    vals = map(get_value, parameters)
    N = isnothing(param_diff_cache_size) ? length(vals) : param_diff_cache_size
    diffcache = DiffCache(vals, ForwardDiff.pickchunksize(N))

    ParameterCache(free_mask, diffcache, vals[.! free_mask])
end
