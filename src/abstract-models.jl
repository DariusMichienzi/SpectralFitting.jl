export AbstractSpectralModel,
    allocate_model_output,
    AbstractSpectralModelKind,
    Multiplicative,
    Additive,
    Convolutional,
    modelkind,
    AbstractSpectralModelImplementation,
    XSPECImplementation,
    JuliaImplementation,
    implementation,
    invokemodel,
    invokemodel!,
    objective_cache_count

"""
    abstract type AbstractSpectralModelKind

Abstract type of all model kinds. The algebra of models is as follows
```julia
A + A = A
M * M = M
M * A = A
C(A)  = A
```
where `A` is [`Additive`](@ref), `M` is [`Multiplicative`](@ref), and `C` is [`Convolutional`](@ref).
All other operations are prohibited, e.g. `C(M)` or `M * C`. To obtain `M * C` there must be an
additive component, e.g. `M * C(A)`.
"""
abstract type AbstractSpectralModelKind end
"""
    Additive <: AbstractSpectralModelKind
    Additive()

Additive models are effectively the sources of photons, and are the principle building blocks
of composite models. Every additive model has a normalisation parameter which re-scales the
output by a constant factor `K`.

!!! note
    Defining custom additive models requires special care. See [Defining new models](@ref).
"""
struct Additive <: AbstractSpectralModelKind end
"""
    Multiplicative <: AbstractSpectralModelKind
    Multiplicative()

Multiplicative models act on [`Additive`](@ref) models, by element-wise
multiplying the output in each domain bin of the additive model by a different factor.
"""
struct Multiplicative <: AbstractSpectralModelKind end
"""
    Convolutional <: AbstractSpectralModelKind
    Convolutional()

Convolutional models act on the output generated by [`Additive`](@ref) models, similar to
[`Multiplicative`](@ref) models, however may convolve kernels through the output also.
"""
struct Convolutional <: AbstractSpectralModelKind end

"""
    abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end

Supertype of all spectral models, tracking the number type `T` and
[`AbstractSpectralModelKind`](@def) denoted `K`.

## Implementation

Sub-types must implement the following interface (see the function's
documentation for examples):
- [`SpectralFitting.invoke!`](@ref)

The parameters of the model must be of types `FitParam` when default
initialised, as this is used to perform introspection. The boiler plate for a
new model is as follows:

```julia
struct MyNewModel{T} <: AbstractSpectralModel{T,Additive}
    "Normalisation (required by Additive kinds)
    K::T
    "First parameter"
    p1::T
    "Second parameter"
    p2::T
end

# add a default keyword constructor
function MyNewModel(;K = FitParam(1.0), p1 = FitParam(2.0), p2 = FitParam(0.1))
    MyNewModel(K, p1, p2)
end

function SpectralFitting.invoke!(output, domain, model::MyNewModel)
    # implementation must overwrite `output`
    output .= 0
end
```

## Usage

The available API for a spectral model is detailed below:

- [`invokemodel`](@ref) / [`invokemodel!`](@ref): the primary way to invoke a model.
- [`allocate_model_output`](@ref): allocate the output matrix for the model.

The following query functions exist:

- [`modelkind`](@ref) for obtaining `K`
- [`implementation`](@ref) used to ascertain whether we can do things like
  automatic differentiation through this model.
- [`parameter_count`](@ref) to return a compile-time integer representing the
  total number of parameters in the model.
- [`parameter_vector`](@ref) to obtain a vector where every element is a
  [`FitParam`](@ref) in the same order as the struct fields.
- [`parameter_names`](@ref) to obtain a vector of symbols for each parameter.
- [`objective_cache_count`](@ref) how many output arrays this model needs to be
  invoked (only used for [`CompositeModel`](@ref)).
- [`supports`](@ref) what [`AbstractDataLayout`](@ref) are supported by this model.

Conversion functions include:
- [`remake_with_parameters`](@ref) for converting a model from
  [`FitParam`](@ref) type parameters to a primitive type (e.g. `Float64`), or
  for rebuilding models with new values.

The parametric type parameter `T` is the number type of the model and `K`
defines the [`AbstractSpectralModelKind`](@ref).
"""
abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end
supports(::Type{<:AbstractSpectralModel}) = (ContiguouslyBinned(),)

"""
    modelkind(M::Type{<:AbstractSpectralModel})
    modelkind(::AbstractSpectralModel)

Return the kind of model given by `M`: either `Additive`, `Multiplicative`, or `Convolutional`.
"""
modelkind(::Type{<:AbstractSpectralModel{T,K}}) where {T,K} = K()
modelkind(::M) where {M<:AbstractSpectralModel} = modelkind(M)

"""
    abstract type AbstractSpectralModelImplementation end

Details about the implementation are represented by this abstract type, used in
the trait pattern. Concrete types are

- `JuliaImplementation()`: means the model is implemented in the Julia
  programming language.
- `XSPECImplementation()`: means the model is vendored from the XSPEC model
  library.
"""
abstract type AbstractSpectralModelImplementation end
struct XSPECImplementation <: AbstractSpectralModelImplementation end
struct JuliaImplementation <: AbstractSpectralModelImplementation end

"""
    implementation(model::AbstractSpectralModel)
    implementation(::Type{<:AbstractSpectralModel})

Get the [`AbstractSpectralModelImplementation`](@ref) for a given
[`AbstractSpectralModel`](@ref) or model type.

This is used primarily to learn what optimizations we can do with a model, for
example propagating auto-diff gradients through a model or arbitrary precision
numbers.
"""
implementation(::Type{<:AbstractSpectralModel}) = JuliaImplementation()
implementation(model::AbstractSpectralModel) = implementation(typeof(model))

# implementation interface
# never to be called directly
# favour `invokemodel!` instead
"""
    SpectralFitting.invoke!(output, domain, M::Type{<:AbstractSpectralModel}, params...)

Used to define the behaviour of models. Should calculate the output of the model
and write in-place into `output`. The model parameters are passed in the model structure.

!!! warning
    This function should not be called directly. Use [`invokemodel`](@ref)
    instead. `invoke!` is only to define the model, not to use it. Users should
    always call models using [`invokemodel`](@ref) or [`invokemodel!`](@ref) to
    ensure normalisations and closures are accounted for.

## Example

```julia
Base.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Multiplicative}
    p1::T = FitParam(1.0)
    p2::T = FitParam(2.0)
    p3::T = FitParam(3.0)
end
```
would have the arguments passed to `invoke!` as
```julia
function SpectralFitting.invoke!(output, domain, model::MyModel)
    # ...
end
```
"""
invoke!(output, domain, M::AbstractSpectralModel) = error("Not defined for $(M).")

"""
    invokemodel(domain, model::AbstractSpectralModel)

Invoke the [`AbstractSpectralModel`](@ref) given by `model` over the domain `domain`.

This function will perform any normalisation or post-processing tasks that a
specific model kind may require, e.g. multiplying by a normalisation constant for [`Additive`](@ref) models.

!!! note

`invokemodel` allocates the needed output arrays based on the element type of `free_params` to allow
automatic differentation libraries to calculate parameter gradients.

In-place non-allocating variants are the [`invokemodel!`](@ref) functions.

# Example

```julia
model = PowerLaw()
domain = collect(range(0.1, 20.0, 100))

invokemodel(domain, model)
```
"""
function invokemodel(domain, m::AbstractSpectralModel)
    output = allocate_model_output(m, domain)
    invokemodel!(output, domain, m)
    view(output, :, 1)
end

"""
    invokemodel!(output, domain, model)
    invokemodel!(output, domain, model, params::AbstractVector)
    invokemodel!(output, domain, model, params::ParameterCache)

In-place variant of [`invokemodel`](@ref), calculating the output of an
[`AbstractSpectralModel`](@ref) given by `model`, optionally overriding the
parameters using a [`ParameterCache`](@ref) or an `AbstractVector`.

The `output` may not necessarily be a single vector, and one should use
[`allocate_model_output`](@ref) to allocate the output structure.

# Example

```julia
model = PowerLaw()
domain = collect(range(0.1, 20.0, 100))
output = allocate_model_output(model, domain)
invokemodel!(output, domain, model)
```
"""
function invokemodel!(f, e, m::AbstractSpectralModel{<:FitParam})
    # need to extract the parameter values
    parameters = get_value.(parameter_vector(m))
    invokemodel!(f, e, m, parameters)
end
function invokemodel!(f, e, m::AbstractSpectralModel)
    invokemodel!(f, e, m, parameter_vector(m))
end
function invokemodel!(f, e, m::AbstractSpectralModel, cache::ParameterCache)
    invokemodel!(f, e, m, cache.parameters)
end
function invokemodel!(f, e, m::AbstractSpectralModel, parameters::AbstractArray)
    _inner_invokemodel!(f, e, remake_with_parameters(m, parameters))
end
function _inner_invokemodel!(output, domain, model::AbstractSpectralModel)
    _invoke_guard!(output, domain, model)
end
function _invoke_guard!(output, domain, model::AbstractSpectralModel{<:Number,Additive})
    invoke!(output, domain, model)
    # perform additive normalisation
    K = normalisation(model)
    @. output *= K
    output
end
function _invoke_guard!(output, domain, model::AbstractSpectralModel{<:Number})
    invoke!(view(output, :, 1), domain, model)
    output
end

normalisationfield(::Type{<:AbstractSpectralModel{T,Additive}}) where {T} = :K
normalisation(model::AbstractSpectralModel{T,Additive}) where {T} =
    getfield(model, normalisationfield(typeof(model)))

"""
    allocate_model_output(model::AbstractSpectralModel, domain::AbstractVector)

Allocate the output space for the [`AbstractSpectralModel`](@ref) for a given
domain. The output type will be the promoted element type of the model and
domain.

Uses [`construct_objective_cache`](@ref) to construct the appropriate layout.
"""
function allocate_model_output(
    model::AbstractSpectralModel{T1},
    domain::AbstractVector{T2},
) where {T1,T2}
    T = promote_type(T1 <: FitParam ? T1.parameters[1] : T1, T2)
    construct_objective_cache(T, model, domain)
end

function Base.copy(m::AbstractSpectralModel)
    typeof(m)((copy(getproperty(m, f)) for f in fieldnames(typeof(m)))...)
end

# printing
_model_name(model::AbstractSpectralModel) = Base.typename(typeof(model)).name

function _printinfo(io::IO, m::AbstractSpectralModel{T}; bindings = nothing) where {T}
    println(io, _model_name(m))
    println(io, "T = $T")
end

function _printinfo(
    io::IO,
    m::M;
    bindings = nothing,
    parameter_indent = 0,
) where {M<:AbstractSpectralModel{<:FitParam}}
    pvec = parameter_vector(m)
    psym = parameter_names(m)
    params = [s => p for (s, p) in zip(psym, pvec)]
    basename = _model_name(m)
    print(io, "$(basename)\n")

    info_tuples = [get_info_tuple(val) for (_, val) in params]
    # just those of free parameters
    free_infos = [info_tuples[i] for i in eachindex(params) if isfree(last(params[i]))]
    q1 = maximum(j -> length("$(j[1])"), info_tuples)
    # only work out these paddings on free parameters
    q2, q3, q4 = map(2:4) do i
        maximum(j -> length("$(j[i])"), free_infos)
    end

    name_padding = parameter_indent + maximum(params) do (s, _)
        length("$s")
    end

    for (s, param) in params
        if !isnothing(bindings) && !isnothing(get(bindings, s, nothing))
            print(io, lpad(s, name_padding), " -> ")
            printstyled(io, bindings[s], color = :magenta)
            println(io)
        else
            _print_param(
                io,
                param;
                name = String(s),
                name_padding = name_padding,
                pm_padding = q1,
                err_padding = q2,
                range_padding = q3 + q4,
            )
        end
    end
end

function Base.show(io::IO, ::MIME"text/plain", @nospecialize(model::AbstractSpectralModel))
    buff = IOBuffer()
    _printinfo(IOContext(buff, io), model)
    s = String(take!(buff))
    print(io, encapsulate(s))
end

# TODO: all of the below need unit tests that make sure they are type-stable

function closure_and_parameter_types(
    M::Type{<:AbstractSpectralModel{T}},
) where {T<:FitParam}
    FTypes = fieldtypes(M)
    P = count(T -> T<:FitParam, FTypes)
    C = length(FTypes) - P
    FTypes[1:C], FTypes[(C+1):(P+C)]
end

function closure_and_parameter(
    model::M,
) where {M<:AbstractSpectralModel{T}} where {T<:FitParam}
    C, P = closure_and_parameter_types(M)
    tuple = _unpack_as_tuple(model)
    closures = tuple[1:length(C)]
    parameters = tuple[(length(C)+1):(length(C)+length(P))]
    @assert all(i -> i isa FitParam, parameters) "All non-fit parameters must be the first fields in a model structure."
    closures, parameters
end

"""
    parameter_count(m::AbstractSpectralModel)

Return the total number of parameters of the model (i.e. how many fields are
[`FitParam`](@ref).
"""
function parameter_count(::M) where {M<:AbstractSpectralModel{<:FitParam}}
    _, P = closure_and_parameter_types(M)
    length(P)
end

function _unpack_as_tuple(model::M) where {M<:AbstractSpectralModel}
    ((getfield(model, f) for f in fieldnames(M))...,)
end

"""
    remake_with_parameters(model::AbstractSpectralModel, parameters)

Rebuild the model with all [`FitParam`](@ref) type parameters replaced with
`parameters`, in the same order as they appear in the fields of the struct.
"""
function remake_with_parameters(model::AbstractSpectralModel, parameters::AbstractVector)
    indices = (1:parameter_count(model)...,)
    remake_with_parameters(model, map(i -> parameters[i], indices))
end

function remake_with_parameters(model::AbstractSpectralModel, parameters::Tuple)
    closures, _ = closure_and_parameter(model)
    Base.typename(typeof(model)).wrapper(closures..., parameters...)
end

function parameter_vector(model::AbstractSpectralModel{<:FitParam})
    _, params = closure_and_parameter(model)
    collect(params)
end

# TODO: docstring
parameter_names(m::AbstractSpectralModel) = parameter_names(typeof(m))
function parameter_names(M::Type{<:AbstractSpectralModel{<:FitParam}})
    C, P = closure_and_parameter_types(M)
    fieldnames(M)[(length(C)+1):end]
end

make_parameter_cache(model::AbstractSpectralModel) = ParameterCache(parameter_vector(model))

function _all_parameters_with_symbols(model::AbstractSpectralModel)
    psym = parameter_names(model)
    pvec = parameter_vector(model)
    pvec, [:m => s for s in psym]
end

function _all_parameters_with_names(model::AbstractSpectralModel)
    ps, syms = _all_parameters_with_symbols(model)
    ps, ["$(i[1]).$(i[2])" for i in syms]
end

paramtype(::Type{<:AbstractSpectralModel{T}}) where {T} = paramtype(T)

Base.setproperty!(model::AbstractSpectralModel{<:FitParam}, s::Symbol, v::Number) =
    getfield(model, s).value = v
